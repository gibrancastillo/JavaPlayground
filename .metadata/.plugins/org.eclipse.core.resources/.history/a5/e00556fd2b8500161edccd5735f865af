package com.ccc.rest.filters;

import java.io.IOException;

import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.ext.Provider;

/**
 * There are two types of filters in JAX-RS:
 * <> ContainerRequestFilter - a filter that executes before the HTTP Request is served.  Here you are intercepting the HTTP Request.
 * 
 * <> ContainerResponseFilter - a filter that executes after the HTTP Response is prepared and it's about to be sent to the client.
 *                              Here you are intercepting the HTTP Response.
 * 
 * This custom HTTP Request/Response Filter class uses the @Provider annotation to register itself with JAX-RS, so that JAX-RS knows that
 * this custom HTTP Request/Response Filter is available, so when this messenger RESTful API is about to server an HTTP Request to a Resource base API
 * and is about to sent the HTTP Response to the client JAX-RS is able to find this custom response filter and utilize it accordingly.
 * 
 * In order to register this class as a custom LoggingFilter for JAX-RS we annotate the class with @Provider to this class.
 * 
 * REST APIs are stateless, this means that the RESTful application running on the server does not maintain any state, it does not maintain information
 * that persist across multiple request.  In other words, the client and the server do not remember any previous interaction between each other; therefore,
 * classic session-based authentication does not work for REST APIs.
 * 
 * The following are a list of some of the REST Web Service APIs stateless authentication mechanisms:
 * <> Basic Auth (Basic Access Authentication):  Every time the client sends an HTTP Request to the server, the client authenticates with the server.
 *                                               In other words, the client sends the username/password information.
 *    Client-Side
 *    The username/password are sent in the HTTP Header of the HTTP Request.  The way to do this is by following a specific protocol, you take the username
 *    and password and you concatenate them separated by a colon, like this "username:password" and then you do Base64 encoding on the "username:password"
 *    String and you get an encoded String "dXNIcm5hbWU6cGFzc3dvcmQ=".  You take this Base64 encoded String and in your HTTP Header of your HTTP Request you
 *    create a new header parameter with a key called "Authorization" and with a value "Basic dXNIcm5hbWU6cGFzc3dvcmQ="
 * 
 *    Server-Side
 *    The Server gets the HTTP Request and it examines the HTTP Header of the HTTP Request and the server finds the "Authorization" header and gets the value.
 *    The Server checks the first word of the value and it notices that it says 'Basic' so the server knows that this is Basic Auth and then it gest the second
 *    word, which is the Base64 encoded String 'dXNIcm5hbWU6cGFzc3dvcmQ=' and the server does Basic64 decoding to get "username:password" and then the server
 *    can do a match for the username and password.
 *    
 *    Note that Base64 encoding and decoding is not encryption; the Base64 encoded String is not secure; therefore, when using Basic Auth you always
 *    use the HTTPS protocol to send the HTTP Request, so the username/password are protected.
 *    Security is not the intent of the encoding step.  Rather, the intent of the encoding is to encode non-HTTP-compatible characters that may be in the username
 *    and/or password into those that are HTTP-compatible.
 *    
 *    Advantages:  Simple, Stateless server, and supported by all web browsers
 *    Disadvantages:  Requires HTTPS, Subject to replay attacks, "Logout" is tricky (Browser caching)
 * 
 * <> Digest Access Authentication:  This actually does encryption off a secret key that's being sent in the HTTP Header of the HTTP Request.  It does not use
 *                                   username and password, instead it has a secret id
 *                                   
 * <> Asymmetric Cryptography:  This is the public key cryptography, there is a public key and a private key (digital pen)
 * 
 * <> OAuth:  1.0 and 2.0 are very different, but this REST Web Service API stateless authentication is gaining a lot of popularity.
 * 
 * <> JSON Web Tokens:  
 * 
 * @author gecasti
 *
 */
@Provider
public class LoggingFilter implements ContainerRequestFilter, ContainerResponseFilter {
	
	/**
	 * This is an HTTP Request filter method.  The JAX-RS framework is going to call this filter method implementation, before
	 * the HTTP Request is served.  Here you have a chance to modify the HTTP Request before is served to the Resource base API class; for instance,
	 * by adding an HTTP Header value.
	 */
	@Override
	public void filter(ContainerRequestContext requestContext) throws IOException {
		System.out.println("HTTP Request Filter");
		System.out.println("HTTP Request Headers: " + requestContext.getHeaders());
	}
	
	/**
	 * This is an HTTP Response filter method.  The JAX-RS framework is going to call this filter method implementation, then
	 * the HTTP Response is about to be sent.  Here you have a chance to modify the HTTP Response before is sent to the client; for instance,
	 * by adding an HTTP Header value.
	 */
	@Override
	public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
		System.out.println("HTTP Response Filter");
		System.out.println("HTTP Response Headers: " + responseContext.getHeaders());
	}	
}